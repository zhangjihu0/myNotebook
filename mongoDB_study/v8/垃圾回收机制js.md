## javascript 垃圾回收器
自动垃圾回收机制管理内存
### 优化
简化开发，节省代码。
### 缺点
无法完整掌握内存
### node的内存管理 
服务器端的node有必要管理内存
内存泄漏后果严重，有可能引起文件描述符耗尽和连接占满
### v8内存限制
64位 1.4G 32位 0.7G
无法操作大对象
node.js中的js对象都是通过V8进行分配管理内存的
最大1.4G 
    console.log(process.memoryUsage())
    {
      rss:161546624,进程的常驻内存16M 有7M不属于堆内存；
      heapTotal:9751808,V8已经申请到的堆内存数量9M
      heapUsed:3952576,V8已经使用的堆内存总量3M
    }
### 为何
V8 的垃圾收集原理
1.5内存 完全收集一次 需要1 秒以上
这一秒钟 叫stop the world,应用的性能和响应能力都会下降
## 如何打开内存限制
node --max-old-space-size=2000 app.js 单位是M

node --max-new-space-size = 1024 app.js 单位是KB
一旦初始化成功，生效不能再修改
### 的垃圾回收机制
V8 是基于分代的垃圾回收。分为新生代和老生代
按存活时间来划分的。年龄小的新生代，年龄大的老生代
#### 内存分代
- 年龄小的新生代，
  由两个区域组成。[][].
  默认情况下 64位 新生代 内存是32M
            32位 新生代 内存 16M
  新生代由两块 from to 区域组成。每块 64位 16M 32位8M 
- 年代大的老生代
  默认情况下 64位 老生代 内存是1400M
            32位 老生代 内存是700M
#### 新生代的垃圾回收算法：
大多数被分配到这里，这里是他们出生的地方
这个区域很小，但垃圾回收非常频繁
当指针到达末尾时，要进行垃圾回收
新生代通过scavenge算法进行回收
scavenge
新生代匹配一分为2， 每个16M
一个使用，一个空闲
开始垃圾回收时，会检测from里的存活对象，如果还活着，拷贝到to 空间里
非存在对象，释放空间；
完成复制后，from 和to 角色互换；
复制的过程采用广度优先的策略，从根对象出现，遍历所有能力直接访问的对象
优点 是速度快 效率高
缺点是浪费空间
但是由于存活对象少，空间小，所有这种方案最合适
当一个对象经历过多次闪复制依然存活时，它就是生存周期比较长的对象 它会被移动到老生代，这个移动过程称之为晋升或升级
有两种情况会晋升
1.经历过5次以上的回收
2.to的空间内存使用占比超过20%，或超大对象
###老生代垃圾回收算法
mark-sweep mark-compact
  标记-清理   标记-整理
###mark-sweep
标记活着的对象，随后清理标记阶段没有标记的对象，只清理死亡的对象，活着的对象在新生代比较多，在老生代比较少
问题在于清除后会出现内存不连续的情况，这种内存碎片会对后续的分配造成影响
如果要分配一个大对象，碎片空间无法分配
###mark-compact
标记死亡后进行整理，活着的对象往左移动，移动完成后，直接清理掉外界的内存。
### incremental making 增量标记
以上三种回收时都需要暂停程序运行，收集完成后才进行恢复。stap the world
新生代影响不大，老生代内存空间大，存活对象多，耗时比较长，比较严重
把标记改为了增量标记。将一口气的停顿拆分成了多个小步骤。
做完一步程序运行一会，垃圾回收和应用程序运行交替进行。
停顿时间可以减少到1/6左右
### 查看垃圾回收日志
#### trace_gc
node --trace_gc --trace_gc_verbose traceGc.js>trace.log
知道何时执行GC,每次GC的时间以及每个区域的内存占用情况
### Prof
可以得到V8执行性能分析，包括垃圾回收的占用时间
ngryman/v8-windows-tickprocessor //可视化的工具GC
### 如何让内存高效的工作；
我们让垃圾回收更高效的工作；
#### 如何释放内存
scope closure
内存指标
堆内存总得是小于RSS，NOD中的内存并不全都是由V8进行分配的不通过V8分配的内存称为堆 外内存






